<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>基于函数值变速的音视频播放器</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      * { box-sizing: border-box; }
      html, body {
        height: 100%;
      }
      body {
        font-family: system-ui, -apple-system, sans-serif;
        margin: 0;
        padding: 16px;
        background: #0f172a;
        color: #e5e7eb;
        overflow: hidden;
      }
      h1 { font-size: 20px; margin-top: 0; margin-bottom: 16px; }
      h2 { font-size: 16px; margin: 0 0 12px 0; }

      .container {
        display: flex;
        gap: 16px;
        max-width: 1800px;
        margin: 0 auto;
        align-items: flex-start;
        height: calc(100vh - 32px);
        overflow: auto;
        scrollbar-width: none;
        -ms-overflow-style: none;
      }
      .container::-webkit-scrollbar { display: none; }
      .left-col {
        width: 60%;
        flex-shrink: 0;
        display: flex;
        flex-direction: column;
        gap: 24px;
      }
      .right-col {
        flex: 1;
        min-width: 300px;
        position: sticky;
        top: 16px;
      }

      .panel {
        background: #020617;
        border-radius: 12px;
        padding: 20px;
        box-shadow: 0 10px 30px rgba(15, 23, 42, 0.6);
        border: 1px solid #1e293b;
      }

      .resizer {
        width: 8px;
        background: #1e293b;
        border-radius: 4px;
        cursor: col-resize;
        align-self: stretch;
        transition: background 0.2s, transform 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .resizer::after {
        content: "";
        width: 2px;
        height: 24px;
        background: #4b5563;
        border-radius: 2px;
      }
      .resizer:hover,
      .resizer.active {
        background: #3b82f6;
      }
      .resizer:hover::after,
      .resizer.active::after {
        background: #fff;
      }

      @media (max-width: 1024px) {
        .container { flex-direction: column; }
        .left-col { width: 100% !important; }
        .resizer { display: none; }
        .right-col { position: static; width: 100%; }
      }

      label { display: block; margin-top: 12px; font-size: 13px; color: #9ca3af; }
      input[type="text"], input[type="number"], select {
        width: 100%; padding: 8px 10px; border-radius: 8px;
        border: 1px solid #1f2937; background: #0f172a;
        color: #e5e7eb; font-size: 13px; margin-top: 6px;
        transition: border-color 0.2s;
      }
      input[type="text"]:focus, input[type="number"]:focus, select:focus {
        outline: none; border-color: #3b82f6;
      }
      input[type="file"] { margin-top: 6px; }

      button {
        margin-top: 16px; margin-right: 8px; padding: 8px 16px;
        border-radius: 999px; border: none; background: #3b82f6;
        color: white; cursor: pointer; font-size: 13px; font-weight: 500;
        transition: all 0.2s;
      }
      button.secondary { background: #4b5563; }
      button:disabled { opacity: 0.5; cursor: not-allowed; }
      button:hover:not(:disabled) { opacity: 0.9; transform: translateY(-1px); box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3); }
      button.secondary:hover:not(:disabled) { box-shadow: 0 4px 12px rgba(75, 85, 99, 0.3); }

      .row { display: flex; gap: 16px; margin-top: 8px; }
      .row > div { flex: 1; }
      small { font-size: 12px; color: #6b7280; display: inline-block; margin-top: 4px; line-height: 1.4; }

      video { width: 100%; border-radius: 8px; background: black; display: block; }
      .status {
        margin-top: 16px; font-size: 13px; color: #10b981; font-weight: bold;
        padding: 12px; background: rgba(16, 185, 129, 0.1);
        border-radius: 8px; border: 1px solid rgba(16, 185, 129, 0.2);
      }
      canvas {
        touch-action: none;
        display: block;
        width: 100%;
        border-radius: 8px;
        background: #0f172a;
        border: 1px solid #1f2937;
      }
    </style>
  </head>
  <body>
    <div class="container" id="mainContainer">
      <div class="left-col" id="leftCol">
        <div class="panel">
          <h1>函数变速控制台</h1>

          <label style="margin-top: 0;">
            选择音视频文件：
            <input id="fileInput" type="file" accept="audio/*,video/*" />
          </label>

          <div class="row">
            <div style="flex: 2;">
              <label>函数输入方式：
                <select id="inputModeSelect">
                  <option value="formula">常规公式输入</option>
                  <option value="draw">图形绘制</option>
                  <option value="preset">预设函数</option>
                </select>
              </label>
            </div>
            <div style="flex: 1;">
              <label>最大倍速限制：
                <input id="maxSpeedInput" type="number" value="4" step="0.25" />
              </label>
            </div>
          </div>

          <div id="formulaInputSection" style="margin-top: 12px;">
            <label>
              自定义数学公式：
              <input id="formulaInput" type="text" value="sin((t / d) * pi * 4) + 2" />
              <small>支持常用数学函数如 sin, cos, pi, pow 等。变量 t 为当前时间，d 为总时长。函数值将作为播放速率。</small>
            </label>
          </div>

          <div id="presetSection" style="display: none; margin-top: 12px;">
            <label>选择预设函数：
              <select id="presetSelect">
                <option value="constant">恒定速度</option>
                <option value="linear">线性加速</option>
                <option value="sine">正弦波</option>
                <option value="pulse">脉冲波</option>
              </select>
            </label>
          </div>

          <div style="margin-top: 20px;">
            <label id="sourceCanvasLabel" style="margin-top: 0; margin-bottom: 8px; color: #3b82f6; font-weight: bold;">
              函数图像预览
            </label>
            <canvas id="sourceCanvas" width="800" height="300"></canvas>

            <div id="drawExtraSettings" style="display: none;">
              <div id="closedCurveSettings" style="display: none; margin-top: 12px; padding: 12px; background: rgba(16, 185, 129, 0.1); border-radius: 8px; border: 1px solid rgba(16, 185, 129, 0.2);">
                <label style="margin-top: 0; color: #10b981;">已检测到闭合曲线，请选择遍历方向：</label>
                <select id="drawDirectionSelect" style="background: #0f172a; border-color: rgba(16, 185, 129, 0.3);">
                  <option value="cw">顺时针</option>
                  <option value="ccw">逆时针</option>
                </select>
              </div>
              <div style="margin-top: 12px;">
                <button id="clearDrawBtn" class="secondary">清除绘制</button>
                <button id="smoothDrawBtn" class="secondary">平滑曲线</button>
                <small style="margin-left: 8px;">点击或拖拽绘制函数曲线。系统会自动将最小值调整为 1，最大值映射到最大倍速限制。</small>
              </div>
            </div>
          </div>

          <div style="margin-top: 20px; border-top: 1px solid #1e293b; padding-top: 16px;">
            <button id="applyBtn">应用函数并开始播放</button>
            <button id="stopBtn" class="secondary" disabled>停止变速控制</button>
            <div class="status" id="statusText">请选择音视频文件并设置函数</div>
          </div>
        </div>

        <div class="panel">
          <label style="margin-top: 0; margin-bottom: 8px; color: #e5e7eb; font-weight: bold;">
            播放速率时间曲线
          </label>
          <canvas id="previewCanvas" width="800" height="300"></canvas>
        </div>
      </div>

      <div class="resizer" id="resizer"></div>

      <div class="right-col" id="rightCol">
        <div class="panel" style="padding: 16px;">
          <h2 style="font-size: 16px; margin-top: 0; margin-bottom: 12px; color: #e5e7eb;">媒体播放器</h2>
          <video id="media" controls></video>
        </div>
      </div>
    </div>

    <script>
      /** @typedef {{x:number,y:number}} Point */

      const fileInput = document.getElementById('fileInput');
      const formulaInput = document.getElementById('formulaInput');
      const applyBtn = document.getElementById('applyBtn');
      const stopBtn = document.getElementById('stopBtn');
      const statusText = document.getElementById('statusText');
      const media = document.getElementById('media');

      const inputModeSelect = document.getElementById('inputModeSelect');
      const formulaSection = document.getElementById('formulaInputSection');
      const presetSection = document.getElementById('presetSection');
      const drawExtraSettings = document.getElementById('drawExtraSettings');
      const closedCurveSettings = document.getElementById('closedCurveSettings');
      const drawDirectionSelect = document.getElementById('drawDirectionSelect');
      const sourceCanvasLabel = document.getElementById('sourceCanvasLabel');

      const maxSpeedInput = document.getElementById('maxSpeedInput');
      const presetSelect = document.getElementById('presetSelect');

      const sourceCanvas = document.getElementById('sourceCanvas');
      const clearDrawBtn = document.getElementById('clearDrawBtn');
      const smoothDrawBtn = document.getElementById('smoothDrawBtn');
      const previewCanvas = document.getElementById('previewCanvas');

      /** @type {(t:number,d:number)=>number|null} */
      let currentSpeedFunc = null;
      let running = false;
      let rafId = null;
      let videoDuration = 100;

      /** @type {Point[]} */
      let drawnPoints = [];
      let isDrawing = false;

      function clamp(v, min, max) {
        return Math.min(max, Math.max(min, v));
      }

      media.addEventListener('loadedmetadata', () => {
        if (Number.isFinite(media.duration) && media.duration > 0) {
          videoDuration = media.duration;
          liveUpdate();
        }
      });

      function parseMathFormula(expr) {
        let parsed = String(expr).toLowerCase();
        parsed = parsed.replace(/\^/g, '**');
        parsed = parsed.replace(/\bpi\b/g, 'Math.PI');
        parsed = parsed.replace(/\be\b/g, 'Math.E');
        const mathFuncs = ['sin', 'cos', 'tan', 'asin', 'acos', 'atan', 'log', 'exp', 'sqrt', 'abs', 'min', 'max', 'round', 'ceil', 'floor'];
        mathFuncs.forEach((func) => {
          const regex = new RegExp('\\b' + func + '\\b', 'g');
          parsed = parsed.replace(regex, 'Math.' + func);
        });
        return parsed;
      }

      function compileUserFunc(expr) {
        const jsExpr = parseMathFormula(expr);
        // eslint-disable-next-line no-new-func
        const fn = new Function('t', 'd', 'Math', '"use strict"; return (' + jsExpr + ');');
        return function (t, d) {
          return fn(t, d, Math);
        };
      }

      function getPresetFunc(key) {
        switch (key) {
          case 'constant': return function () { return 1; };
          case 'linear': return function (t, d) { return 1 + (t / d) * 3; };
          case 'sine': return function (t, d) { return Math.sin((t / d) * Math.PI * 4) + 2; };
          case 'pulse': return function (t, d) { return Math.pow(Math.sin((t / d) * Math.PI * 10), 2) * 2 + 1; };
          default: return function () { return 1; };
        }
      }

      function isClosedCurve(threshold) {
        const thr = threshold || 0.05;
        if (drawnPoints.length < 3) return false;
        const first = drawnPoints[0];
        const last = drawnPoints[drawnPoints.length - 1];
        const dx = first.x - last.x;
        const dy = first.y - last.y;
        return Math.sqrt(dx * dx + dy * dy) < thr;
      }

      function isDrawnClockwise(points) {
        let sum = 0;
        for (let i = 0; i < points.length; i++) {
          const p1 = points[i];
          const p2 = points[(i + 1) % points.length];
          sum += (p2.x - p1.x) * (p2.y + p1.y);
        }
        return sum < 0;
      }

      function computeArcLengths(points, scaleX, scaleY) {
        const sx = scaleX || 800;
        const sy = scaleY || 300;
        const lengths = [0];
        let totalLength = 0;
        for (let i = 1; i < points.length; i++) {
          const dx = (points[i].x - points[i - 1].x) * sx;
          const dy = (points[i].y - points[i - 1].y) * sy;
          totalLength += Math.sqrt(dx * dx + dy * dy);
          lengths.push(totalLength);
        }
        return { lengths: lengths, totalLength: totalLength };
      }

      function getDrawnFunc(maxSpeed) {
        if (!drawnPoints.length) return function () { return 1; };

        const localTop = Math.min.apply(null, drawnPoints.map(function (p) { return p.y; }));
        const localBottom = Math.max.apply(null, drawnPoints.map(function (p) { return p.y; }));
        const yRange = localBottom - localTop;

        function mapYToSpeed(y) {
          if (yRange < 0.01) return 1 + (1 - y) * (maxSpeed - 1);
          const mappedFraction = (y - localTop) / yRange;
          return 1 + (1 - mappedFraction) * (maxSpeed - 1);
        }

        if (isClosedCurve()) {
          const points = drawnPoints.concat([drawnPoints[0]]);
          const info = computeArcLengths(points, 800, 300);
          const lengths = info.lengths;
          const totalLength = info.totalLength;
          const shouldReverse = (drawDirectionSelect.value === 'cw') !== isDrawnClockwise(points);

          return function (t, d) {
            let normalizedT = clamp(t / Math.max(d, 0.1), 0, 1);
            if (shouldReverse) normalizedT = 1 - normalizedT;
            const targetArc = normalizedT * totalLength;
            let interpolatedY = points[0].y;
            for (let i = 0; i < points.length - 1; i++) {
              if (targetArc >= lengths[i] && targetArc <= lengths[i + 1]) {
                const ratio = (targetArc - lengths[i]) / (lengths[i + 1] - lengths[i]);
                interpolatedY = points[i].y + (points[i + 1].y - points[i].y) * ratio;
                break;
              }
            }
            return mapYToSpeed(interpolatedY);
          };
        } else {
          const isRightToLeft = drawnPoints[drawnPoints.length - 1].x < drawnPoints[0].x;
          /** @type {Point[]} */
          const monotonicPoints = [];
          if (isRightToLeft) {
            let lowestX = Infinity;
            drawnPoints.forEach(function (p) {
              if (p.x < lowestX) { monotonicPoints.push(p); lowestX = p.x; }
            });
            monotonicPoints.reverse();
          } else {
            let highestX = -Infinity;
            drawnPoints.forEach(function (p) {
              if (p.x > highestX) { monotonicPoints.push(p); highestX = p.x; }
            });
          }
          if (monotonicPoints.length === 0) return function () { return 1; };

          return function (t, d) {
            const targetX = clamp(t / Math.max(d, 0.1), 0, 1);
            let interpolatedY = monotonicPoints[0].y;
            for (let i = 0; i < monotonicPoints.length - 1; i++) {
              if (targetX >= monotonicPoints[i].x && targetX <= monotonicPoints[i + 1].x) {
                const ratio = (targetX - monotonicPoints[i].x) / (monotonicPoints[i + 1].x - monotonicPoints[i].x || 1);
                interpolatedY = monotonicPoints[i].y + (monotonicPoints[i + 1].y - monotonicPoints[i].y) * ratio;
                break;
              }
            }
            return mapYToSpeed(interpolatedY);
          };
        }
      }

      function buildSpeedFunc() {
        const mode = inputModeSelect.value;
        const maxSpeedLimit = Math.max(1.1, Number(maxSpeedInput.value) || 4);
        let rawFunc;
        try {
          if (mode === 'formula') rawFunc = compileUserFunc(formulaInput.value.trim());
          else if (mode === 'preset') rawFunc = getPresetFunc(presetSelect.value);
          else rawFunc = getDrawnFunc(maxSpeedLimit);
        } catch (e) {
          return null;
        }
        return function (t, d) {
          let v = rawFunc(t, d);
          if (!Number.isFinite(v)) v = 1;
          return clamp(v, 1, maxSpeedLimit);
        };
      }

      function liveUpdate() {
        const f = buildSpeedFunc();
        if (f) {
          currentSpeedFunc = f;
          drawBothCanvases(media.currentTime);
          statusText.style.color = '#10b981';
          statusText.textContent = '实时生效，当前视频时长：' + videoDuration.toFixed(1) + 's';
        } else {
          statusText.style.color = '#ef4444';
          statusText.textContent = '输入错误，请检查语法结构。';
        }
      }

      function updateUI() {
        const mode = inputModeSelect.value;
        formulaSection.style.display = mode === 'formula' ? 'block' : 'none';
        drawExtraSettings.style.display = mode === 'draw' ? 'block' : 'none';
        presetSection.style.display = mode === 'preset' ? 'block' : 'none';
        sourceCanvas.style.pointerEvents = mode === 'draw' ? 'auto' : 'none';
        sourceCanvas.style.cursor = mode === 'draw' ? 'crosshair' : 'default';

        if (mode === 'draw') {
          sourceCanvasLabel.textContent = '绘制图像曲线';
          closedCurveSettings.style.display = isClosedCurve() ? 'block' : 'none';
        } else if (mode === 'formula') {
          sourceCanvasLabel.textContent = '图像曲线预览';
        } else {
          sourceCanvasLabel.textContent = '预设波形预览';
        }
        liveUpdate();
      }

      function drawBothCanvases(currentTime) {
        const w = sourceCanvas.width;
        const h = sourceCanvas.height;
        const padding = 40;
        const plotW = w - padding * 2;
        const plotH = h - padding * 2;
        const mode = inputModeSelect.value;
        const maxSpeed = Math.max(1.1, Number(maxSpeedInput.value) || 4);
        const displayTime = currentTime !== undefined && isFinite(currentTime)
          ? clamp(currentTime, 0, videoDuration)
          : undefined;
        let activeSpeed = 1;
        if (displayTime !== undefined && currentSpeedFunc) activeSpeed = currentSpeedFunc(displayTime, videoDuration);

        const sCtx = sourceCanvas.getContext('2d');
        if (sCtx) {
          sCtx.clearRect(0, 0, w, h);
          sCtx.strokeStyle = '#1f2937';
          sCtx.lineWidth = 1;
          sCtx.setLineDash([4, 4]);
          sCtx.beginPath();
          sCtx.moveTo(0, h / 2);
          sCtx.lineTo(w, h / 2);
          sCtx.stroke();
          sCtx.setLineDash([]);

          if (mode === 'draw' && drawnPoints.length > 0) {
            sCtx.strokeStyle = '#3b82f6';
            sCtx.lineWidth = 2;
            sCtx.beginPath();
            drawnPoints.forEach(function (p, index) {
              if (index === 0) sCtx.moveTo(p.x * w, p.y * h);
              else sCtx.lineTo(p.x * w, p.y * h);
            });
            if (isClosedCurve()) sCtx.lineTo(drawnPoints[0].x * w, drawnPoints[0].y * h);
            sCtx.stroke();

            sCtx.fillStyle = '#10b981';
            sCtx.beginPath();
            sCtx.arc(drawnPoints[0].x * w, drawnPoints[0].y * h, 4, 0, Math.PI * 2);
            sCtx.fill();
          } else if (mode !== 'draw' && currentSpeedFunc) {
            sCtx.strokeStyle = '#3b82f6';
            sCtx.lineWidth = 2;
            sCtx.beginPath();
            for (let i = 0; i <= w; i++) {
              const t = (i / w) * videoDuration;
              const spd = currentSpeedFunc(t, videoDuration);
              const yFrac = 1 - (spd - 1) / (maxSpeed - 1);
              if (i === 0) sCtx.moveTo(i, yFrac * h);
              else sCtx.lineTo(i, yFrac * h);
            }
            sCtx.stroke();
          }
        }

        const pCtx = previewCanvas.getContext('2d');
        if (pCtx && currentSpeedFunc) {
          pCtx.clearRect(0, 0, w, h);
          pCtx.strokeStyle = '#1f2937';
          pCtx.lineWidth = 1;
          pCtx.setLineDash([2, 2]);
          for (let i = 0; i <= 5; i++) {
            const y = padding + (plotH * i) / 5;
            pCtx.beginPath();
            pCtx.moveTo(padding, y);
            pCtx.lineTo(w - padding, y);
            pCtx.stroke();
          }
          for (let i = 0; i <= 10; i++) {
            const x = padding + (plotW * i) / 10;
            pCtx.beginPath();
            pCtx.moveTo(x, padding);
            pCtx.lineTo(x, h - padding);
            pCtx.stroke();
          }
          pCtx.setLineDash([]);
          pCtx.strokeStyle = '#4b5563';
          pCtx.lineWidth = 2;
          pCtx.beginPath();
          pCtx.moveTo(padding, h - padding);
          pCtx.lineTo(w - padding, h - padding);
          pCtx.stroke();
          pCtx.beginPath();
          pCtx.moveTo(padding, padding);
          pCtx.lineTo(padding, h - padding);
          pCtx.stroke();

          pCtx.fillStyle = '#9ca3af';
          pCtx.font = '12px system-ui';
          pCtx.textAlign = 'center';
          for (let i = 0; i <= 10; i++) {
            pCtx.fillText(
              ((videoDuration * i) / 10).toFixed(0) + 's',
              padding + (plotW * i) / 10,
              h - padding + 20
            );
          }
          pCtx.textAlign = 'right';
          for (let i = 0; i <= 5; i++) {
            pCtx.fillText(
              (1 + (maxSpeed - 1) * (5 - i) / 5).toFixed(1) + 'x',
              padding - 10,
              padding + (plotH * i) / 5 + 4
            );
          }

          pCtx.strokeStyle = '#3b82f6';
          pCtx.lineWidth = 2;
          pCtx.beginPath();
          for (let i = 0; i <= 400; i++) {
            const t = (videoDuration * i) / 400;
            const spd = currentSpeedFunc(t, videoDuration);
            const px = padding + (plotW * i) / 400;
            const py = padding + plotH * (1 - (spd - 1) / (maxSpeed - 1));
            if (i === 0) pCtx.moveTo(px, py);
            else pCtx.lineTo(px, py);
          }
          pCtx.stroke();

          if (displayTime !== undefined) {
            const px = padding + (plotW * displayTime) / videoDuration;
            const py = padding + plotH * (1 - (activeSpeed - 1) / (maxSpeed - 1));
            pCtx.strokeStyle = '#10b981';
            pCtx.lineWidth = 1;
            pCtx.setLineDash([4, 4]);
            pCtx.beginPath();
            pCtx.moveTo(px, padding);
            pCtx.lineTo(px, h - padding);
            pCtx.stroke();
            pCtx.setLineDash([]);
            pCtx.fillStyle = '#10b981';
            pCtx.beginPath();
            pCtx.arc(px, py, 6, 0, Math.PI * 2);
            pCtx.fill();
            pCtx.strokeStyle = '#ffffff';
            pCtx.lineWidth = 2;
            pCtx.stroke();
          }
        }
      }

      [inputModeSelect, formulaInput, presetSelect, maxSpeedInput, drawDirectionSelect].forEach(function (el) {
        el.addEventListener('input', updateUI);
        el.addEventListener('change', updateUI);
      });

      function addPointFromEvent(ev) {
        const rect = sourceCanvas.getBoundingClientRect();
        drawnPoints.push({
          x: clamp((ev.clientX - rect.left) / rect.width, 0, 1),
          y: clamp((ev.clientY - rect.top) / rect.height, 0, 1),
        });
        liveUpdate();
      }

      sourceCanvas.addEventListener('pointerdown', function (ev) {
        if (inputModeSelect.value !== 'draw') return;
        ev.preventDefault();
        isDrawing = true;
        drawnPoints = [];
        addPointFromEvent(ev);
      });
      sourceCanvas.addEventListener('pointermove', function (ev) {
        if (!isDrawing || inputModeSelect.value !== 'draw') return;
        ev.preventDefault();
        addPointFromEvent(ev);
      });
      const finishDraw = function () {
        if (isDrawing) {
          isDrawing = false;
          updateUI();
        }
      };
      sourceCanvas.addEventListener('pointerup', finishDraw);
      sourceCanvas.addEventListener('pointerleave', finishDraw);

      clearDrawBtn.addEventListener('click', function () {
        drawnPoints = [];
        updateUI();
      });
      smoothDrawBtn.addEventListener('click', function () {
        if (drawnPoints.length < 3) return;
        const smoothed = [];
        for (let i = 0; i < drawnPoints.length; i++) {
          let sumY = 0;
          let sumX = 0;
          let count = 0;
          for (let j = i - 2; j <= i + 2; j++) {
            if (j >= 0 && j < drawnPoints.length) {
              sumX += drawnPoints[j].x;
              sumY += drawnPoints[j].y;
              count++;
            }
          }
          smoothed.push({ x: sumX / count, y: sumY / count });
        }
        drawnPoints = smoothed;
        updateUI();
      });

      function startControl() {
        if (!currentSpeedFunc) return;
        if (!media.src) {
          statusText.style.color = '#ef4444';
          statusText.textContent = '请先选择一个音/视频文件。';
          return;
        }
        running = true;
        applyBtn.disabled = true;
        stopBtn.disabled = false;
        statusText.style.color = '#10b981';

        const loop = function () {
          if (!running) return;
          const t = media.currentTime;
          if (isFinite(t)) {
            try {
              const speed = currentSpeedFunc(t, videoDuration);
              media.playbackRate = speed;
              drawBothCanvases(t);
              statusText.textContent =
                '▶ 正在播放 - 时间: ' +
                t.toFixed(1) +
                's / ' +
                videoDuration.toFixed(1) +
                's, 当前速率: ' +
                speed.toFixed(2) +
                'x';
            } catch (err) {
              stopControl();
              return;
            }
          }
          rafId = requestAnimationFrame(loop);
        };

        if (!media.paused) rafId = requestAnimationFrame(loop);
        media.addEventListener(
          'play',
          function () {
            if (running && rafId === null) rafId = requestAnimationFrame(loop);
          },
          { once: false }
        );
        media.addEventListener(
          'pause',
          function () {
            if (rafId !== null) {
              cancelAnimationFrame(rafId);
              rafId = null;
            }
          },
          { once: false }
        );
      }

      function stopControl() {
        running = false;
        applyBtn.disabled = false;
        stopBtn.disabled = true;
        if (rafId !== null) {
          cancelAnimationFrame(rafId);
          rafId = null;
        }
        media.playbackRate = 1;
        statusText.textContent = '⏹ 已停止变速控制，恢复自然 1x。';
        if (currentSpeedFunc) drawBothCanvases(media.currentTime);
      }

      fileInput.addEventListener('change', function () {
        const file = fileInput.files && fileInput.files[0];
        if (!file) return;
        media.src = URL.createObjectURL(file);
        media.load();
        media.play().catch(function () {});
      });

      applyBtn.addEventListener('click', startControl);
      stopBtn.addEventListener('click', stopControl);

      const leftCol = document.getElementById('leftCol');
      const resizer = document.getElementById('resizer');
      let isResizing = false;

      resizer.addEventListener('pointerdown', function (e) {
        isResizing = true;
        resizer.classList.add('active');
        document.body.style.cursor = 'col-resize';
        document.body.style.userSelect = 'none';
      });

      document.addEventListener('pointermove', function (e) {
        if (!isResizing) return;
        const container = leftCol.parentElement;
        if (!container) return;
        const containerRect = container.getBoundingClientRect();
        let newWidth = e.clientX - containerRect.left;
        if (newWidth < 300) newWidth = 300;
        if (newWidth > containerRect.width - 300) newWidth = containerRect.width - 300;
        leftCol.style.width = (newWidth / containerRect.width) * 100 + '%';
        if (currentSpeedFunc) {
          drawBothCanvases(media.currentTime);
        }
      });

      document.addEventListener('pointerup', function () {
        if (isResizing) {
          isResizing = false;
          resizer.classList.remove('active');
          document.body.style.cursor = 'default';
          document.body.style.userSelect = '';
        }
      });

      updateUI();
    </script>
  </body>
</html>

